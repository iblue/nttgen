# nttgen

Generates parameters for NTT (number theoretic transforms), which can be
used to multiply big numbers.

For a number theoretic transform of length `2^k`, there are the
following paramaters needed:

1. A prime modulus `p = l * 2^k + 1`
1. A (non-primitive) root of unity where `omega^(2^k) = 1 mod p`
1. A scaling factor to calculate the inverse `2*scale = 1 mod p`

## Quick outline of number theoretic transforms

In order to transform a vector `(a, b, c, d)`, one needs to calculate

```
a' = a + b           + c           + d            mod p
b' = a + omega   * b + omega^2 * c + omega^3 * d  mod p
c' = a + omega^2 * b + omega^4 * c + omega^6 * d  mod p
d' = a + omega^3 * b + omega^6 * c + omega^9 * d  mod p
```

The inverse transform is
```
a' = scale * (a + b            + c            + d           )  mod p
b' = scale * (a + omega^-1 * b + omega^-2 * c + omega^-3 * d)  mod p
c' = scale * (a + omega^-2 * b + omega^-4 * c + omega^-6 * d)  mod p
d' = scale * (a + omega^-3 * b + omega^-6 * c + omega^-9 * d)  mod p
```

Note that `omega^-1 = omega^3, omega^-2 = omega^2, omega^-3 = omega^1,
omega^-4 = 1, omega^-5 = omega^3, ...`

This can be done in `O(n log(n))` using an FFT-equivalent algorithmn.

# Example
We can use the following parameters as generated by the code to multiply
a polynomial in `O(n * log(n))`:

```
p     = 4179340454199820289
omega = 3360066027580426122 (for 2^2)
scale = 2089670227099910145
```

- `(10, 11, 0, 0)` transforms `(21, 3526002669786125040, 4179340454199820288, 653337784413695269)`
- `(23, 42, 0, 0)` transforms to `(65, 3204538169783827610,4179340454199820270, 974802284415992725)`
- A pointwise multiplication modulo p gives `(1365, 301250839524003525, 19, 3878089614675816300)`
- Inverse transform gives `(230, 673, 462, 0)`
- Therefore `(10 + 11x) * (23 + 42x) = 230 + 673x + 462x^2`
